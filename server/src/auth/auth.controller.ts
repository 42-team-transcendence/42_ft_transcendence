import { Controller, Post ,Param, Body, HttpCode, HttpStatus, UseGuards, Res, Req, Response, Get, UseInterceptors} from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { AuthService } from "./auth.service";
import { AuthDto, SignInAuthDto } from "./dto";
import { JwtGuard } from "./guard/at.guard";
import { Tokens } from "./types";
import { RtGuard } from "./guard/rt.guard";
import { IntraGuard } from "./guard/intra.guard";
import { GetUser } from "../auth/decorator"
import { User } from '@prisma/client'; //User Typescript type generated by Prisma
import { ConfigService } from "@nestjs/config";
import { ApiTags } from '@nestjs/swagger';
import { DoubleAuthService } from "./doubleauth.service";
import * as speakeasy from 'speakeasy';
import { Enable2faDto } from "./dto/Enable2fa.dto";
import { GetUserDto } from "./dto";
import { Request } from 'express';
import { ExcludeSensitiveData } from "src/interceptors/excludeSensitiveDataInterceptor";

@ApiTags('auth')
@Controller('auth')
export class AuthController {
    constructor(private authService: AuthService,
                private configService: ConfigService,
				private  readonly doubleAuthService: DoubleAuthService,) {}

/*********************************************************************************************************/

    @Post('signup')
    @UseInterceptors(ExcludeSensitiveData)
    @HttpCode(HttpStatus.CREATED)
    signup(
        @Body() dto: AuthDto,
        @Res()/*({ passthrough: true })*/ res: Response
    ) {
        return (this.authService.signup(dto, res));
    }

/*********************************************************************************************************/

	@Post('enable-2fa')
	@HttpCode(HttpStatus.CREATED)
	async enable2FA(
		@Body() dto: Enable2faDto,
	) {
        try {
            // Check if the user has already set up 2FA before allowing the setup process again (Optional)
            // You can add an additional check here to prevent users from setting up 2FA multiple times.

            // Generate the 2FA secret and store it in the database
            const secret = speakeasy.generateSecret();
            await this.doubleAuthService.saveUserSecret(dto.email, secret.base32);

            // Generate the QR code and return the representation of the QR code in the response
            const qrCodeData = await this.doubleAuthService.generateQRCode(secret.otpauth_url);
            return ({ qrCodeData });
        } catch (error) {
            console.error('Error enabling 2FA:', error);
            throw new Error('Failed to enable 2FA.');
        }
	}


/*********************************************************************************************************/

    @Post('signin')
    @UseInterceptors(ExcludeSensitiveData)
    @HttpCode(HttpStatus.OK)
    signin(
        @Body() dto: SignInAuthDto,
        @Res() res: Response
    ) {
        return (this.authService.signin(dto, res));

    }

    @Post('signin2FA')
    @HttpCode(HttpStatus.OK)
    signin2FA(
        @Body() dto: SignInAuthDto,
        @Res() res: Response
    ) {
        return (this.authService.signin2FA(dto, res));
    }

/*********************************************************************************************************/

    @Get('/login/42')
    login_42() {
        return(this.authService.login_42 ())
    }

    @Get('/callback/42')
	@UseGuards(IntraGuard)
	async callback42(@GetUser() user, @Res() res: Response) {
        try {
            return (this.authService.callback42(user, res))
        } catch (error) {
            throw error;
        }
	}

  @Get('/2fa_42')
	async callback42_2fa(@Req() req: Request, @Res() res: Response) {
        const email = req.query.email as string; // Assurez-vous de v√©rifier que les valeurs existent ou sont valides
		return (this.authService.callback42_2fa(email, res))
	}

  @UseInterceptors(ExcludeSensitiveData)
	@Get('/userByMail/:email')
	async getUserBymail(
		@Param('email') email: string
	) {
		return (this.authService.getUserBymail(email));
	}

    @UseInterceptors(ExcludeSensitiveData)
    @Get('/userByNick/:nickname')
	async getUserByNick(
		@Param('nickname') nickname: string
	) {
		return (this.authService.getUserByNick(nickname));
	}

/*********************************************************************************************************/

    @UseGuards(JwtGuard)
    @Post('logout')
    @HttpCode(HttpStatus.OK)
    logout(
        @GetUser() user: GetUserDto,
        @Res(/*({ passthrough: true })*/) res: Response
    ) {
        return (this.authService.logout(user.sub, res));
    }

/*********************************************************************************************************/

    @UseGuards(RtGuard) //link this guard (check for refresh token) to our refresh token strategy
    @Post('refresh')
    @HttpCode(HttpStatus.OK)
    refresh(
        @GetUser() user: GetUserDto,
        @Res(/*({ passthrough: true })*/) res: Response
    ) {
        return (this.authService.refresh(user.sub, user.refreshToken, res));
    }

/*************************************************************************************************/

}

